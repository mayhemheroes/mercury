// csv.cc
//
// Comma-Separated Value (CSV) format processing for IANA (and
// similar) files

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <regex>
#include <fstream>
#include <unistd.h>

#include "csv.h"

void write_preamble(const std::string &filename,
                    const std::string &preprocname,
                    std::vector<std::tuple<std::string, std::string, std::string>> file_and_class,
                    FILE *f=stdout) {

    std::time_t timenow = time(NULL);
    static char timestamp[128] = { '\0' };
    strftime(timestamp, sizeof(timestamp) - 1, "%Y-%m-%dT%H:%M:%SZ", gmtime(&timenow));
    fprintf(f,
            "// %s\n"
            "//\n"
            "// this file was autogenerated at %s\n"
            "// you should edit the source file(s) instead of this one\n"
            "//\n"
            "// source files:\n",
            filename.c_str(),
            timestamp);
    for (const auto &fc : file_and_class) {
        fprintf(f, "//     %s\n", std::get<0>(fc).c_str());
    }
    fprintf(f,
            "//\n\n"
            "#ifndef %s\n"
            "#define %s\n\n",
            preprocname.c_str(),
            preprocname.c_str());
}

void write_postamble(const char *filename, FILE *f=stdout) {
    fprintf(f, "\n#endif // %s\n\n", filename);
}

void write_class(const std::vector<std::tuple<std::string, std::string>> &params,
                 const char *classname,
                 const char *sname,
                 FILE *f=stdout) {

    // prepare padding for alignment
    //
    const char padding[] = "                                                           ";
    size_t max = 0;
    for (const auto &p : params) {
        if (std::get<0>(p).length() > max) { max = std::get<0>(p).length(); }
    }

    fprintf(f,
            "template <typename T>\n"
            "class %s : public encoded<T> {\n"
            "    static_assert(std::is_unsigned_v<T>, \"T must be an unsigned integer\");\n"
            "public:\n"
            "    void write_json(json_object &o) const {\n"
            "        const char *name = get_name();\n"
            "        if (name == nullptr) {\n"
            "            o.print_key_unknown_code(\"%s\", encoded<T>::value());\n"
            "        } else {\n"
            "            o.print_key_string(\"%s\", name);\n"
            "        }\n"
            "    }\n"
            "    enum code {\n",
            classname,
            sname,
            sname);

    for (const auto &p : params) {
        int padlen = max - std::get<0>(p).length();
        fprintf(f, "        %s%.*s = %s,\n", std::get<0>(p).c_str(), padlen, padding, std::get<1>(p).c_str());
    }

    fprintf(f,
            "    };\n"
            "    const char *get_name() const {\n"
            "        switch(encoded<T>::value()) {\n"
            );

    for (const auto &p : params) {
        int padlen = max - std::get<0>(p).length();

        // remove leading underscore, if any, from printed string
        //
        std::string tmp{std::get<0>(p)};
        if (tmp[0] == '_') {
            tmp.erase(0,1);
        }
        fprintf(f, "        case %s:%.*s return \"%s\";\n", std::get<0>(p).c_str(), padlen, padding, tmp.c_str());
    }

    fprintf(f,
            "        default:\n"
            "            ;\n"
            "        }\n"
            "        return nullptr;\n"
            "    }\n"
            "};\n\n");
}

void csv_file_add_mappings(std::vector<std::tuple<std::string, std::string>> &params,
                           std::string filename) {

    bool remove_paren_exprs = true;

    std::ifstream f(filename);
    csv::get_next_line(f);  // ignore first line
    while(f) {

        std::vector<std::string> csv_line = csv::get_next_line(f);
        if (csv_line.size() > 2) {

            std::string value{csv_line[0]};
            std::string keyword{csv_line[1]};

            // transform keyword into an acceptable C++ identifier
            //
            std::replace(keyword.begin(), keyword.end(), '.', '_');
            std::replace(keyword.begin(), keyword.end(), '-', '_');
            std::replace(keyword.begin(), keyword.end(), ' ', '_');
            std::replace(keyword.begin(), keyword.end(), '#', '_');
            if (remove_paren_exprs) {
                size_t lparen = keyword.find('(');
                if (lparen != std::string::npos) {
                    size_t rparen = keyword.find(')', lparen);
                    if (rparen != std::string::npos) {
                        keyword.erase(lparen, rparen);
                    }
                }
                lparen = keyword.find('[');
                if (lparen != std::string::npos) {
                    size_t rparen = keyword.find(']', lparen);
                    if (rparen != std::string::npos) {
                        keyword.erase(lparen, rparen);
                    }
                }
            } else {
                std::replace(keyword.begin(), keyword.end(), '(', '_');
                std::replace(keyword.begin(), keyword.end(), ')', '_');
                std::replace(keyword.begin(), keyword.end(), ']', '_');
                std::replace(keyword.begin(), keyword.end(), '[', '_');
            }
            if (isdigit(keyword[0])) {
                keyword.insert(0, "_");
            }

            // remove duplicate and final underscores
            std::string tmp;
            char last = '\0';
            for (const auto &k : keyword) {
                if (k != '_' or last != '_') {
                    tmp += k;
                }
                last = k;
            }
            if (tmp.back() == '_') {
                tmp.pop_back();
            }

            // add (keyword, value) to vector
            //
            params.emplace_back(tmp, value);
        }
    };

}

void process_iana_csv_file(std::string filename,
                           const std::string &classname,
                           const std::string &sname,
                           FILE *outfile,
                           bool verbose=false) {

    std::string altfile;
    size_t comma = filename.find(",");
    if (comma != std::string::npos) {
        altfile = filename.substr(0, comma);
        filename = filename.substr(comma+1);
    }

    std::vector<std::tuple<std::string, std::string>> params;
    csv_file_add_mappings(params, filename);
    if (altfile != "") {
        csv_file_add_mappings(params, altfile);
    }

    // remove Reserved, Unassigned, and Private elements
    //
    const auto & predicate = [verbose, classname](const std::tuple<std::string, std::string> p){

        bool remove = std::regex_search(std::get<0>(p), std::regex("Reserved.*"))
            or std::regex_search(std::get<0>(p), std::regex("RESERVED"))
            or std::regex_search(std::get<0>(p), std::regex("Unassigned.*"))
            or std::regex_search(std::get<0>(p), std::regex("Private"))
            or not std::regex_search(std::get<1>(p), std::regex("[0-9]*"));

        if (verbose and remove) {
            fprintf(stderr, "note: in class %s: removing (%s, %s)\n", classname.c_str(), std::get<0>(p).c_str(), std::get<1>(p).c_str());
        }
        return remove;
    };
    params.erase(std::remove_if(params.begin(), params.end(), predicate), params.end());

    struct {
        bool operator()(std::tuple<std::string, std::string> &a,
                        std::tuple<std::string, std::string> &b) const {

            std::string &A = std::get<1>(a);
            std::string &B = std::get<1>(b);
            size_t AA;
            size_t BB;
            int base = 10;
            if (A.length() > 1 and A[1] == 'x' and B.length() > 1 and B[1] == 'x') {
                base = 16;
            }
            AA = std::stol(A.c_str(), nullptr, base);
            BB = std::stol(B.c_str(), nullptr, base);
            return AA < BB;
        }
    } less;
    std::sort(params.begin(), params.end(), less);

    write_class(params, classname.c_str(), sname.c_str(), outfile);

}

void usage(const char *progname) {
    fprintf(stderr, "usage: %s outfile=<of> <infile.csv>:<classname> [ <infile.csv>:<classname> ... ]\n", progname);
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[]) {

    // process command line arguments
    //
    bool verbose = false;
    std::string outfilename;
    std::string dirname;
    std::vector<std::tuple<std::string, std::string, std::string>> file_and_class;
    for (int i=1; i<argc; i++) {
        std::string s(argv[i]);
        size_t colon = s.find(":");
        if (colon != std::string::npos) {
            std::string prefix{s.substr(0, colon)};
            std::string suffix{s.substr(colon+1)};
            std::string sname;
            size_t colon2 = suffix.find(":");
            if (colon2 != std::string::npos) {
                sname = suffix.substr(colon2+1);
                suffix = suffix.substr(0, colon2);
            } else {
                sname = suffix;
            }
            file_and_class.emplace_back(prefix, suffix, sname);
        } else {
            if (std::regex_search(s, std::regex{"outfile=.*"})) {
                outfilename = s.substr(8);
            }
            if (std::regex_search(s, std::regex{"verbose=true"})) {
                verbose = true;
            }
            if (std::regex_search(s, std::regex{"dir=.*"})) {
                dirname = s.substr(4);
            }
        }
    }

    if (outfilename == "") {
        fprintf(stderr, "error: no output file specified on command line\n");
        usage(argv[0]);
    }
    FILE *outfile = fopen(outfilename.c_str(), "w");

    if (dirname != "") {
        if (chdir(dirname.c_str()) != 0) {
            fprintf(stderr, "error: could not change working directory to %s\n", dirname.c_str());
            usage(argv[0]);
        }
    }

    // create preprocessor names for #defines
    //
    std::string preproc{outfilename};
    std::replace(preproc.begin(), preproc.end(), '.', '_');
    std::transform(preproc.begin(), preproc.end(), preproc.begin(), ::toupper);

    // write out preambles, tables, and postamble
    //
    write_preamble(outfilename, preproc, file_and_class, outfile);
    for (const auto &fc : file_and_class) {
        process_iana_csv_file(std::get<0>(fc), std::get<1>(fc), std::get<2>(fc), outfile, verbose);
    }
    write_postamble(preproc.c_str(), outfile);

    return 0;
}
